# FaceRecognitionServer

此项目来自于我的CSDN专栏文章《从零开始写高性能的人脸识别服务器》，本项目重心在于高性能，前端写的比较low，欢迎大家一键三连，批评指正。下面给出专栏地址：

[从零开始写高性能的人脸识别服务器（一）](https://blog.csdn.net/qq_34037358/article/details/110426408)

[从零开始写高性能的人脸识别服务器（二）](https://blog.csdn.net/qq_34037358/article/details/110428524)

[从零开始写高性能的人脸识别服务器（三）](https://blog.csdn.net/qq_34037358/article/details/110797105)

[从零开始写高性能的人脸识别服务器（四）](https://blog.csdn.net/qq_34037358/article/details/110797939)

​	如今AI的应用越来越广，但是对于AI产品技术的部署落地是一个很多人都会忽视的地方，因为大部分的AI服务都是基于Python的，将基于Python的AI程序如何部署到Web或者其他平台是一个问题，本专栏将从零开始写一个高性能支持高并发的人脸识别服务器。因为本人的技术栈是Java，所以使用Java的高性能网络IO模型库Netty进行服务器的开发，AI的模型大部分都是Python进行开发的，所以也使用了基于Python的人脸识别框架**face_recoginize**用来开发人脸识别的微服务。由于AI模型的加载一般都很耗时，所以把Python的AI程序做成微服务，服务器和AI微服务之间通过redis队列进行通信。

​	Java高性能网络模型框架首选Netty。人脸识别程序选用基于Python的人脸识别库**face_recoginize**.选用Redis做消息队列。因为模型在预加载是会很耗时，所以将Python人脸识别程序包装成微服务。

​	由于Python全局解释器锁（GIL）的存在，解释器解释执行任何 Python 代码时，都需要先获得这把锁才行，在遇到 I/O 操作时会释放这把锁。如果是纯计算的程序，没有 I/O 操作，解释器会每隔 100 次操作就释放这把锁，让别的线程有机会执行（这个次数可以通过 sys.setcheckinterval 来调整）。所以虽然 CPython 的线程库直接封装操作系统的原生线程，但 CPython 进程做为一个整体，同一时间只会有一个获得了 GIL 的线程在跑，其它的线程都处于等待状态等着 GIL 的释放。也就是说，对Python而言，计算密集型的多线程，其实性能和单线程是一样的。解决方法就是同时运行多个Python程序，也就是采用多进程的方式。

​	Java服务器收到数据之后，将数据存储在redis的key1中，此时产生一个key2（存储Python程序的处理结果）。Java使用随机数获取随机的处理进程。将key1存储到该进程监听的队列中，然后Java监听key2获取Python进程的处理结果，拿到结果之后返回给客户端。

​	客户端我写了C的和Html的。C的程序使用的是**Qt5.9.9** + **opencv-2.4.11** + **protobuf-3.1.0**， 之所以这样选，是因为之前是基于QT5.14开发的，后面发现程序写完之后发给导师，导师的电脑是win7，程序打开就崩溃，这也是为啥都说华为现在还在用VS2013的原因，因为只有MSVC2013版本的才可以兼容win7和win10。然后选择MSVC2013之后，protobuf的版本就不能太高，因为高版本的protobuf都是基于C++11的高级特征，MSVC只支持一小部分的C++11特征，所以使用高版本的会因为不兼容而出错。


